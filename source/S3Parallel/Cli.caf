import &StandardImport, {} &colors

class Cli
  @optionRegExp: /^--(.+)$/
  @evalJsRegExp: /^js:(.*)$/
  @numberRegExp:
    ///i
      ^
      [-+]?
      ( # floating point
        [0-9]*
        \.
        [0-9]+
      | # integer
        [0-9]+
      )

      # exponent
      ([eE][-+]?[0-9]+)?
      $

  @parseArgs: (args)->
    currentOptionName = :arg
    commandNames = currentOption = []
    each arg, i in args into options = {}
      if option = arg.match @optionRegExp
        currentOption = options[currentOptionName = lowerCamelCase option[1]] = []
      else
        currentOption.push
          switch
          when @numberRegExp.test arg then arg / 1
          when @evalJsRegExp.test arg
            evalMatch = arg.match @evalJsRegExp
            try eval evalMatch[1]
            catch error
              log.error
                evaluationError: {}
                  option: currentOptionName
                  source: evalMatch[1]
                  raw:    arg
                  error

          else arg

    {}
      commandNames
      options: object o, k in options
        switch o.length
        when 0 then true
        when 1 then o[0]
        else o

  @_selectCommand: (commands, defaultCommand, parsedArgs) ->
    parsedArgs extract commandNames
    commandFunction = commands[commandName = lowerCamelCase commandNames[0] || defaultCommand]
    unless isFunction(commandFunction) && !isClass commandFunction
      commandFunction = null
      commandName = null

    merge parsedArgs, {}
      commandFunction
      commandName

  @_showCommandSummary: (commandName, {alias, description, options}) ->
    commandName = dashCase commandName
    log "\n-----------------------\n#{colors.bold colors.brightWhite 'commandName: #{commandName}'} #{alias && '(#{alias})'}"
    log description
    if options
      log "\noptions: " + colors.green (array v, k from-object options with k when !v.advanced).sort().join ', '
      log "detailed help: " + colors.green "#{commandName} --help"

  @_showOptionDetails: (option, details) ->
    switch
    when details is String  then description = details
    when (details is Array) && details.length == 2  then [argument, description] = details
    when details is Object                          then {argument, description, advanced} = details
    else
      log.warn {} option, details
      throw new Error "expecting options details to be string, 2-length array or object"
    log colors.blue("option: ") + colors.green " --#{option} #{colors.yellow argument if argument}" + if advanced then colors.grey " (advanced)" else ''
    log "  " + description + "\n"

  @_showCommandDetails: (command, {alias, description, options}) ->
    log "\n-----------------------\n#{colors.bold colors.brightWhite 'Command: #{command}'} #{alias && '(#{alias})'}"
    log description + "\n"
    options && each option in Object.keys(options).sort()
      @_showOptionDetails option, options[option]

  @_showDoc: (doc, {options: {help}, commandName}, startFile) =>
    log
      """
        #{startFile} help:

        Usage: #{&path.basename startFile} command [options]

    if doc?
      {commands, description} = doc
      if description
        log "\n#{description}\n"

      if commands
        commands = object v, k from commands with-key lowerCamelCase k
        if help && commands[commandName]
          @_showCommandDetails commandName, commands[commandName]
        else
          each commandName in Object.keys(commands).sort()
            @_showCommandSummary commandName, commands[commandName]

    unless doc?.commands
      log
        """
          Commands: #{}
            Object.keys commands
            .join ', '

  @start: (cliConfig) =>
    cliConfig extract commands, defaultCommand, doc, argv = process.argv
    [nodeJs, startFile, args...] = argv
    parsedComandLine = @_selectCommand commands, defaultCommand, @parseArgs args
    if (parsedComandLine extract options, commandName, commandFunction) && !options.help

      if parsedComandLine.options.verbose
        log {}
          command: commandName
          options

      Promise.then -> commandFunction options
      .then (result) -> result? && log result

    else
      @_showDoc cliConfig.doc, parsedComandLine, startFile
