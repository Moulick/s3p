import &ArtStandardLib, &ArtClassSystem, &Lib

class S3P

  @getBucketSummary: (options) =>
    size = 0
    @each options, ({Size}) -> size += Size
    .then (count) ->
      {} count, size

  ##
    IN:
      options:
        aggressive: false - if true, will make a little more S3 requests to increase parallelism
        debug: false
        showProgress: <Bool/false> log progress
        prefix: <String/NULL> only scan within a given prefix
        limit: <Number/1000> limit items per call; generally the default of 1000 is best (max allowed by AWS is 1000)
        bucket:
        maxRequests: <Number> limit how many requests will be used - aborts nicely if reached
          nicely: finishes current function calls, logs message, does no more work, throws error
    OUT:
      {}}
        itemsFound
        itemsProcessed
        requestsUsed
  @each: (options) =>
    options extract
      bucket, limit = 1000, maxRequests, prefix = '', showProgress
      debug, aggressive
      map
      s3 = &Lib/S3

    _reduce = options.reduce

    # statistics
    itemsFound =
    requestsUsed =
    maxOutstanding =
    outstanding = 0

    if showProgress
      startTime = currentSecond()
      report = (message) ->
        duration = currentSecond() - startTime
        itemsPerSecond = (itemsFound / duration)
        efficiency = (itemsFound / (requestsUsed * limit)) * 100 | 0

        log "progress: items: #{itemsFound}, requests: #{requestsUsed}, items/s: #{itemsPerSecond | 0}, efficiency: #{efficiency}%, outstanding: #{outstanding}, duration: #{durationString duration}  #{message}"
      progressReporter = interval 1000, report

    # OUT: count of times map was applied
    applyF = (items) ->
      itemsFound += items.length
      unless map
        Promise.resolve items.length
      else
        Promise.all each a in-array items with map a
        .then -> items.length

    eachRecursive = (startAfter, stopAt, usePrefixBisect = false, debugContext) =>
      return Promise.resolve(0) if requestsUsed >= maxRequests || startAfter >= stopAt

      middleKey = getBisectKey startAfter, stopAt, usePrefixBisect

      report() if showProgress == :verbose
      debug && log "" debug: START: #{pad debugContext ? :root, 10} startAfter: #{debugKey startAfter}  middleKey: #{debugKey middleKey}  stopAt: #{debugKey stopAt}  usePrefixBisect: #{usePrefixBisect}

      lastLeftKey = lastRightKey = undefined
      rawLeftCount = rawRightCount = null

      requestsUsed += 2
      maxOutstanding = Math.max maxOutstanding, outstanding += 2

      Promise.all []
        s3.list {} bucket, limit, startAfter
        s3.list {} bucket, limit, startAfter: middleKey

      .finally -> outstanding -= 2

      .then ([rawLeftItems, rawRightItems]) ->
        rawLeftCount  = rawLeftItems?.length
        rawRightCount = rawRightItems?.length

        leftItems   = array item in-array rawLeftItems  when item.Key <= middleKey
        rightItems  = array item in-array rawRightItems when item.Key <= stopAt

        lastLeftKey  = peek(leftItems)?.Key
        lastRightKey = peek(rightItems)?.Key

        Promise.all []
          applyF leftItems
          applyF rightItems

      .then ([leftCount, rightCount]) ->
        recurseLeft     = leftCount >= limit
        recurseRight    = rightCount >= limit

        leftStartAfter  = lastLeftKey
        leftStopAt      = middleKey
        rightStartAfter = lastRightKey
        rightStopAt     = stopAt

        leftUsePrefixBisect = rightCount == 0

        # OPTIMIZATION: The code will work without this, but this lets us skip one recursion step. It may speed things up, but it appears to actually use more calls.
        if aggressive && leftCount == 0 && recurseRight
          recurseLeft = true
          leftUsePrefixBisect = true
          leftStartAfter = lastRightKey
          leftStopAt = newMiddleKey = getBisectKey lastRightKey, rightStopAt
          rightStartAfter = newMiddleKey

        recurse = if recurseLeft then if recurseRight then :both else :left else :right
        if debug == :verbose
          log
            """
              -------------------------------------------------------------
              debug:
                INPUTS:
                  startAfter:       #{debugKey startAfter}
                  middleKey:        #{debugKey middleKey}
                  stopAt:           #{debugKey stopAt}
                  usePrefixBisect:  #{usePrefixBisect}
                RESULTS: (before recursion)
                  overlap:          #{if lastLeftKey < middleKey then :no else if lastLeftKey == lastRightKey then :full else :partial}
                  lastLeftKey:      #{debugKey lastLeftKey}
                  lastRightKey:     #{debugKey lastRightKey}
                  counts:           applied: [#{leftCount}, #{rightCount}] raw: [#{rawLeftCount}, #{rawRightCount}]
                PLAN:
                  recurse:              #{recurse}
                  leftStartAfter:       #{recurseLeft && debugKey leftStartAfter}
                  leftStopAt:           #{recurseLeft && debugKey leftStopAt}
                  leftUsePrefixBisect:  #{recurseLeft && leftUsePrefixBisect}
                  rightStartAfter:      #{recurseRight && debugKey rightStartAfter}
                  rightStopAt:          #{recurseRight && debugKey rightStopAt}

        Promise.all []
          if recurseLeft
            eachRecursive leftStartAfter,   leftStopAt,   leftUsePrefixBisect,  if recurseRight then :recurse-BL else :recurse-L
            .then (c) -> c + leftCount
          else leftCount

          if recurseRight
            eachRecursive rightStartAfter,  rightStopAt,  false,                if recurseLeft then :recurse-BR else :recurse-R
            .then (c) -> c + rightCount
          else rightCount

        .then ([leftCount, rightCount]) -> leftCount + rightCount

      .tapCatch (error) -> log.error eachRecursive: {} startAfter, stopAt, usePrefixBisect, error

    eachRecursive prefix, getLastKeyWithPrefix prefix
    .finally -> progressReporter?.stop()
    .then (count) ->
      report? :DONE
      info = {}
        itemsFound, requestsUsed, options, maxOutstanding
        averageItemsPerRequest: (itemsFound / requestsUsed)
        elapsedSeconds =        currentSecond() - startTime
        itemsPerSecond:         itemsFound / elapsedSeconds
        requestsPerSecond:      requestsUsed / elapsedSeconds

      if requestsUsed > maxRequests
        e = Error "S3Tools.each maxRequestsReached:\n" + formattedInspect info
        e.info = info
        throw e

      else info

  @summarize: (options) =>
    size = count = 0
    @each options, ({Size}) ->
      count++
      size += Size