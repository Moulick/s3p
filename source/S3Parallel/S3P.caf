import &ArtStandardLib, &ArtClassSystem, &Lib

debugKey = (key) ->
  if key?
    tail = 0
    i = lastIndex = key.length - 1
    while key[i] == lastKeyChar do i--
    if i < lastIndex
      key.slice 0, i + 1
      + "(#{lastKeyChar}*#{lastIndex - i})"
    else key
  else "(#{'' + key})"

class S3P

  ##
    IN:
      options:
        debug: false
        showProgress: <Bool/false> log progress
        prefix: <String/NULL> only scan within a given prefix
        limit: <Number/1000> limit items per call; generally the default of 1000 is best (max allowed by AWS is 1000)
        bucket:
        maxRequests: <Number> limit how many requests will be used - aborts nicely if reached
          nicely: finishes current function calls, logs message, does no more work, throws error
    OUT:
      {}}
        itemsFound
        itemsProcessed
        requestsUsed

  @each: (options, f, S3 = &Lib/S3) =>
    options extract bucket, limit = 1000, maxRequests, prefix = '', showProgress, debug

    itemsFound = 0
    requestsUsed = 0
    outstanding = 0

    if showProgress
      startTime = currentSecond()
      report = (message) ->
        duration = currentSecond() - startTime
        itemsPerSecond = (itemsFound / duration)
        efficiency = (itemsFound / (requestsUsed * limit)) * 100 | 0

        log "progress: items: #{itemsFound}, requests: #{requestsUsed}, items/s: #{itemsPerSecond | 0}, efficiency: #{efficiency}%, outstanding: #{outstanding}, duration: #{durationString duration}  #{message}"
      progressReporter = interval 1000, report

      # multibar = new &cliProgress.MultiBar
      #   clearOnComplete: false
      #   hideCursor: true
      #   format: "" items:    {value} progress [{bar}] {percentage}%
      #   &cliProgress.Presets.shades_grey

      # itemBar       = multibar.create 100, 0 format: "" items:    {value} progress [{bar}] {percentage}%
      # requestBar    = multibar.create 100, 0 format: "" requests: {value} progress [{bar}] {percentage}%
      # rateBar       = multibar.create 100, 0
      # efficiencyBar = multibar.create 100, 0

    # OUT: count times applied
    applyF = (items, thisStopAt) ->
      count = 0
      Promise.all array item in items when item.Key <= thisStopAt
        count++
        itemsFound++
        f item
      .then -> count

    eachRecursive = (startAfter, stopAt, usePrefixBisect = false) =>
      return 0 if requestsUsed > maxRequests || startAfter >= stopAt

      outstanding++

      middleKey = getBisectKey startAfter, stopAt, usePrefixBisect

      requestsUsed += 2
      debug && log "" debug: startAfter: #{debugKey startAfter}, middleKey: #{debugKey middleKey}, stopAt: #{debugKey stopAt}

      report() if showProgress == :verbose

      lastLeftKey = lastRightKey = undefined

      Promise.all []
        S3.list {} bucket, limit, startAfter
        S3.list {} bucket, limit, startAfter: middleKey
      .then ([leftItems, rightItems]) ->
        lastLeftKey = peek(leftItems)?.Key
        lastRightKey = peek(rightItems)?.Key

        Promise.all []
          applyF leftItems, middleKey
          applyF rightItems, stopAt

      .then ([leftCount, rightCount]) ->
        # debug && log eachRecursive: {} startAfter, middleKey, stopAt, leftItems, rightItems, usePrefixBisect, leftCount, rightCount
        # debug && log "leftItems:\n  " +
        #   array {Key} in leftItems with Key
        #   .join "\n  "
        # debug && log "rightItems:\n  " +
        #   array {Key} in rightItems with Key
        #   .join "\n  "
        debug && log
          if debug == :verbose
            """
              -------------------------------------------------------------
              debug:
                startAfter:    #{debugKey startAfter}
                middleKey:     #{debugKey middleKey}
                stopAt:        #{debugKey stopAt}
                lastLeftKey:   #{debugKey lastLeftKey}
                lastRightKey:  #{debugKey lastRightKey}
                counts:        [#{leftCount}, #{rightCount}]

          else
            "" debug: startAfter: #{debugKey startAfter}, middleKey: #{debugKey middleKey}, stopAt: #{debugKey stopAt}, counts: [#{leftCount}, #{rightCount}], lastLeftKey: #{debugKey lastLeftKey}, lastRightKey: #{debugKey lastRightKey}

        count = leftCount + rightCount

        switch
        when leftCount < limit && rightCount >= limit # happens when their lists overlap
          debug && log "" debug: recurse only (lastRightKey, stopAt)
          eachRecursive
            lastRightKey        # startAfter
            stopAt              # stopAt
          .then (c) -> count + c

        when leftCount < limit # rightCount < limit, by definition
          debug && log "" debug: done! leftCount < limit, no need to recurse, we got them all
          count

        when rightCount == 0 # leftCount >= limit, by definition <-- SPECIAL CASE: usePrefixBisect!
          debug && log "" debug: recurse only (lastLeftKey, middleKey, usePrefixBisect)
          eachRecursive
            lastLeftKey         # startAfter
            middleKey           # stopAt
            true                # usePrefixBisect
          .then (c) -> count + c

        else
          debug && log "" debug: recurse both (lastLeftKey, middleKey) and (lastRightKey, stopAt)
          Promise.all []
            eachRecursive
              lastLeftKey         # startAfter
              middleKey           # stopAt
            eachRecursive
              lastRightKey        # startAfter
              stopAt              # stopAt
          .then ([leftCount, rightCount]) -> leftCount + rightCount + count
      .tapCatch (error) -> log.error eachRecursive: {} startAfter, stopAt, usePrefixBisect, error
      .finally -> outstanding--

    eachRecursive prefix, prefix + lastKeyChar.repeat 1024 - prefix.length
    .then (count) ->
      progressReporter?.stop()
      report? :DONE
      # multibar.stop() if showProgress
      info = {} itemsFound, requestsUsed, options
      if requestsUsed > maxRequests
        e = Error "S3Tools.each maxRequestsReached:\n" + formattedInspect info
        e.info = info
        throw e
      else info

  @summarize: (options) =>
    size = count = 0
    @each options, ({Size}) ->
      count++
      size += Size